import sys
from pathlib import Path

# Add project root to sys.path to allow running tests from this directory
# The project root is 6 levels up from the parent directory of this file.
project_root = str(Path(__file__).resolve().parents[6])
if project_root not in sys.path:
    sys.path.insert(0, project_root)

#
# Copyright Â© 2024 Agora
# This file is part of TEN Framework, an open source project.
# Licensed under the Apache License, Version 2.0, with certain conditions.
# Refer to the "LICENSE" file in the root directory for more information.
#
import json
from typing import Any
from unittest.mock import patch, AsyncMock
import tempfile
import os
import asyncio
import filecmp
import shutil
import threading

from ten_runtime import (
    ExtensionTester,
    TenEnvTester,
    Cmd,
    CmdResult,
    StatusCode,
    Data,
)
from ten_ai_base.struct import TTSTextInput, TTSFlush
from ten_ai_base.message import ModuleVendorException, ModuleErrorVendorInfo


# ================ test dump ================
class ExtensionTesterDump(ExtensionTester):
    def __init__(self):
        super().__init__()
        # Use a fixed path as requested by the user.
        self.dump_dir = "./dump/"
        # Use a unique name for the file generated by the test to avoid collision
        # with the file generated by the extension.
        self.test_dump_file_path = os.path.join(
            self.dump_dir, "test_manual_dump.pcm"
        )
        self.audio_end_received = False
        self.received_audio_chunks = []

    def on_start(self, ten_env_tester: TenEnvTester) -> None:
        """Called when test starts, sends a TTS request."""
        ten_env_tester.log_info("Dump test started, sending TTS request.")

        tts_input = TTSTextInput(
            request_id="tts_request_1",
            text="hello word, hello agora",
        )
        data = Data.create("tts_text_input")
        data.set_property_from_json(None, tts_input.model_dump_json())
        ten_env_tester.send_data(data)
        ten_env_tester.on_start_done()

    def on_data(self, ten_env: TenEnvTester, data) -> None:
        name = data.get_name()
        if name == "tts_audio_end":
            ten_env.log_info("Received tts_audio_end, stopping test.")
            self.audio_end_received = True
            ten_env.stop_test()

    def on_audio_frame(self, ten_env: TenEnvTester, audio_frame):
        """Receives audio frames and collects their data using the lock/unlock pattern."""
        # The 'audio_frame' object is a wrapper around a memory buffer.
        # We must lock the buffer to safely access the data, copy it,
        # and finally unlock the buffer so the runtime can reuse it.
        buf = audio_frame.lock_buf()
        try:
            # We must copy the data from the buffer, as the underlying memory
            # may be freed or reused after we unlock it.
            copied_data = bytes(buf)
            self.received_audio_chunks.append(copied_data)
        finally:
            # Always ensure the buffer is unlocked, even if an error occurs.
            audio_frame.unlock_buf(buf)

    def write_test_dump_file(self):
        """Writes the collected audio chunks to a file."""
        with open(self.test_dump_file_path, "wb") as f:
            for chunk in self.received_audio_chunks:
                f.write(chunk)

    def find_tts_dump_file(self) -> str | None:
        """Find the dump file created by the TTS extension in the fixed dump directory."""
        if not os.path.exists(self.dump_dir):
            return None
        for filename in os.listdir(self.dump_dir):
            if filename.endswith(".pcm") and filename != os.path.basename(
                self.test_dump_file_path
            ):
                return os.path.join(self.dump_dir, filename)
        return None


@patch("elevenlabs_tts2_python.extension.ElevenLabsTTS2")
def test_dump_functionality(MockElevenLabsTTS2):
    """Test that the extension can dump audio to a file."""
    # Create dump directory if it doesn't exist
    dump_dir = "./dump/"
    os.makedirs(dump_dir, exist_ok=True)

    # Mock the ElevenLabsTTS2 class
    mock_client_instance = AsyncMock()

    # Mock the start_connection method
    mock_client_instance.start_connection = AsyncMock()

    # Mock the text_input_queue to avoid blocking
    mock_client_instance.text_input_queue = asyncio.Queue()

    # Mock the text_to_speech_ws_streaming method to consume from queue
    async def mock_text_to_speech_ws_streaming():
        while True:
            try:
                await mock_client_instance.text_input_queue.get()
            except asyncio.CancelledError:
                break

    mock_client_instance.text_to_speech_ws_streaming = (
        mock_text_to_speech_ws_streaming
    )

    # Mock the get_synthesized_audio method to return audio data
    audio_data_queue = asyncio.Queue()
    # Pre-populate the queue - only include text in the final chunk
    audio_data_queue.put_nowait([b"fake_audio_data_1", False, ""])
    audio_data_queue.put_nowait([b"fake_audio_data_2", False, ""])
    audio_data_queue.put_nowait(
        [b"fake_audio_data_3", True, "hello word, hello agora"]
    )

    async def mock_get_synthesized_audio():
        try:
            return await audio_data_queue.get()
        except asyncio.QueueEmpty:
            # If the queue is empty, return a special value to stop the loop
            return [None, True, "STOP_LOOP"]

    mock_client_instance.get_synthesized_audio = mock_get_synthesized_audio
    MockElevenLabsTTS2.return_value = mock_client_instance

    # Create and run the tester
    tester = ExtensionTesterDump()

    # Set up dump configuration
    dump_config = {
        "params": {
            "api_key": "fake_elevenlabs_key_for_mock_testing",
            "dump": True,
            "dump_path": dump_dir,
            "sample_rate": 16000,
        },
    }

    tester.set_test_mode_single(
        "elevenlabs_tts2_python", json.dumps(dump_config)
    )
    tester.run()

    # Verify that audio end was received
    assert tester.audio_end_received, "Audio end event was not received"

    # Write test dump file for comparison
    tester.write_test_dump_file()

    # Find the TTS dump file
    tts_dump_file = tester.find_tts_dump_file()
    assert tts_dump_file is not None, "TTS dump file was not created"

    # Verify that the dump file exists and has content
    assert os.path.exists(
        tts_dump_file
    ), f"TTS dump file {tts_dump_file} does not exist"
    assert os.path.getsize(tts_dump_file) > 0, "TTS dump file is empty"

    # Clean up
    if os.path.exists(tts_dump_file):
        os.remove(tts_dump_file)
    if os.path.exists(tester.test_dump_file_path):
        os.remove(tester.test_dump_file_path)


# ================ test text input end ================
class ExtensionTesterTextInputEnd(ExtensionTester):
    def __init__(self):
        super().__init__()
        self.ten_env: TenEnvTester | None = None
        self.first_request_completed = False
        self.second_request_sent = False
        self.audio_end_count = 0

    def on_start(self, ten_env_tester: TenEnvTester) -> None:
        """Called when test starts, sends the first TTS request."""
        self.ten_env = ten_env_tester
        ten_env_tester.log_info(
            "Text input end test started, sending first TTS request."
        )

        tts_input = TTSTextInput(
            request_id="tts_request_1",
            text="hello word, hello agora",
            text_input_end=True,
        )
        data = Data.create("tts_text_input")
        data.set_property_from_json(None, tts_input.model_dump_json())
        ten_env_tester.send_data(data)
        ten_env_tester.on_start_done()

    def send_second_request(self):
        """Send a second TTS request with the same request_id."""
        if self.ten_env is None:
            return

        tts_input = TTSTextInput(
            request_id="tts_request_1",
            text="this should be ignored",
            text_input_end=True,
        )
        data = Data.create("tts_text_input")
        data.set_property_from_json(None, tts_input.model_dump_json())
        self.ten_env.send_data(data)
        self.second_request_sent = True

    def on_data(self, ten_env: TenEnvTester, data) -> None:
        name = data.get_name()
        if name == "tts_audio_end":
            self.audio_end_count += 1
            ten_env.log_info(f"Received tts_audio_end #{self.audio_end_count}")

            if self.audio_end_count == 1 and not self.second_request_sent:
                # Send second request after first one completes
                self.send_second_request()
            elif self.audio_end_count == 2:
                ten_env.log_info(
                    "Received second tts_audio_end, stopping test."
                )
                ten_env.stop_test()


@patch("elevenlabs_tts2_python.extension.ElevenLabsTTS2")
def test_text_input_end_logic(MockElevenLabsTTS2):
    """Test that the extension handles text_input_end correctly."""
    # Mock the ElevenLabsTTS2 class
    mock_client_instance = AsyncMock()

    # Mock the start_connection method
    mock_client_instance.start_connection = AsyncMock()

    # Mock the text_input_queue to avoid blocking
    mock_client_instance.text_input_queue = asyncio.Queue()

    # Mock the text_to_speech_ws_streaming method to consume from queue
    async def mock_text_to_speech_ws_streaming():
        while True:
            try:
                await mock_client_instance.text_input_queue.get()
            except asyncio.CancelledError:
                break

    mock_client_instance.text_to_speech_ws_streaming = (
        mock_text_to_speech_ws_streaming
    )

    # Mock the get_synthesized_audio method to return audio data
    audio_data_queue = asyncio.Queue()
    # Pre-populate the queue for two requests
    audio_data_queue.put_nowait([b"fake_audio_data_1", False, ""])
    audio_data_queue.put_nowait(
        [b"fake_audio_data_2", True, "hello word, hello agora"]
    )
    audio_data_queue.put_nowait([b"fake_audio_data_3", False, ""])
    audio_data_queue.put_nowait(
        [b"fake_audio_data_4", True, "this should be ignored"]
    )

    async def mock_get_synthesized_audio():
        try:
            return await audio_data_queue.get()
        except asyncio.QueueEmpty:
            # If the queue is empty, return a special value to stop the loop
            return [None, True, "STOP_LOOP"]

    mock_client_instance.get_synthesized_audio = mock_get_synthesized_audio
    MockElevenLabsTTS2.return_value = mock_client_instance

    # Create and run the tester
    tester = ExtensionTesterTextInputEnd()
    tester.set_test_mode_single("elevenlabs_tts2_python")
    tester.run()

    # Verify that both audio end events were received
    assert (
        tester.audio_end_count == 2
    ), f"Expected 2 audio end events, got {tester.audio_end_count}"


# ================ test flush ================
class ExtensionTesterFlush(ExtensionTester):
    def __init__(self):
        super().__init__()
        self.flush_sent = False
        self.audio_end_received = False
        self.received_audio_chunks = []

    def on_start(self, ten_env_tester: TenEnvTester) -> None:
        """Called when test starts, sends a TTS request."""
        ten_env_tester.log_info("Flush test started, sending TTS request.")

        tts_input = TTSTextInput(
            request_id="tts_request_1",
            text="hello word, hello agora",
        )
        data = Data.create("tts_text_input")
        data.set_property_from_json(None, tts_input.model_dump_json())
        ten_env_tester.send_data(data)
        ten_env_tester.on_start_done()

    def on_audio_frame(self, ten_env: TenEnvTester, audio_frame):
        """Receives audio frames and sends flush after first chunk."""
        buf = audio_frame.lock_buf()
        try:
            copied_data = bytes(buf)
            self.received_audio_chunks.append(copied_data)

            # Send flush after receiving first audio chunk
            if len(self.received_audio_chunks) == 1 and not self.flush_sent:
                self.flush_sent = True
                ten_env.log_info(
                    "Sending flush request after first audio chunk"
                )

                flush_input = TTSFlush(
                    flush_id="tts_request_1",
                )
                flush_data = Data.create("tts_flush")
                flush_data.set_property_from_json(
                    None, flush_input.model_dump_json()
                )
                ten_env.send_data(flush_data)
        finally:
            audio_frame.unlock_buf(buf)

    def on_data(self, ten_env: TenEnvTester, data) -> None:
        name = data.get_name()
        if name == "tts_audio_end":
            ten_env.log_info("Received tts_audio_end, stopping test.")
            self.audio_end_received = True
            ten_env.stop_test()
        elif name == "tts_flush_end":
            ten_env.log_info("Received tts_flush_end")

    def get_calculated_audio_duration_ms(self) -> int:
        """Calculate expected audio duration based on received chunks."""
        total_bytes = sum(len(chunk) for chunk in self.received_audio_chunks)
        sample_rate = 16000
        channels = 1
        sample_width = 2
        bytes_per_second = sample_rate * channels * sample_width
        duration_seconds = total_bytes / bytes_per_second
        return int(duration_seconds * 1000)


@patch("elevenlabs_tts2_python.extension.ElevenLabsTTS2")
def test_flush_logic(MockElevenLabsTTS2):
    """Test that the extension handles flush correctly."""
    # Mock the ElevenLabsTTS2 class
    mock_client_instance = AsyncMock()

    # Mock the start_connection method
    mock_client_instance.start_connection = AsyncMock()

    # Mock the text_input_queue to avoid blocking
    mock_client_instance.text_input_queue = asyncio.Queue()

    # Mock the text_to_speech_ws_streaming method to consume from queue
    async def mock_text_to_speech_ws_streaming():
        while True:
            try:
                await mock_client_instance.text_input_queue.get()
            except asyncio.CancelledError:
                break

    mock_client_instance.text_to_speech_ws_streaming = (
        mock_text_to_speech_ws_streaming
    )

    # Mock the handle_flush method and related methods
    mock_client_instance.handle_flush = AsyncMock()
    mock_client_instance.reconnect_connection = AsyncMock()
    mock_client_instance._handle_reconnection = AsyncMock()

    # Mock the get_synthesized_audio method to return audio data
    audio_data_queue = asyncio.Queue()
    # Pre-populate the queue
    audio_data_queue.put_nowait([b"fake_audio_data_1", False, ""])
    audio_data_queue.put_nowait([b"fake_audio_data_2", False, ""])
    audio_data_queue.put_nowait(
        [b"fake_audio_data_3", True, "hello word, hello agora"]
    )

    async def mock_get_synthesized_audio():
        try:
            return await audio_data_queue.get()
        except asyncio.QueueEmpty:
            # If the queue is empty, return a special value to stop the loop
            return [None, True, "STOP_LOOP"]

    mock_client_instance.get_synthesized_audio = mock_get_synthesized_audio
    MockElevenLabsTTS2.return_value = mock_client_instance

    # Create and run the tester
    tester = ExtensionTesterFlush()
    tester.set_test_mode_single("elevenlabs_tts2_python")
    tester.run()

    # Verify that audio end was received
    assert tester.audio_end_received, "Audio end event was not received"
    assert tester.flush_sent, "Flush was not sent"


# ================ test basic functionality ================
class ExtensionTesterBasic(ExtensionTester):
    def __init__(self):
        super().__init__()
        self.audio_end_received = False
        self.received_audio_chunks = []

    def on_start(self, ten_env_tester: TenEnvTester) -> None:
        """Called when test starts, sends a TTS request."""
        ten_env_tester.log_info("Basic test started, sending TTS request.")

        tts_input = TTSTextInput(
            request_id="tts_request_1",
            text="hello word, hello agora",
            text_input_end=True,
        )
        data = Data.create("tts_text_input")
        data.set_property_from_json(None, tts_input.model_dump_json())
        ten_env_tester.send_data(data)
        ten_env_tester.on_start_done()

    def on_data(self, ten_env: TenEnvTester, data) -> None:
        name = data.get_name()
        if name == "tts_audio_end":
            ten_env.log_info("Received tts_audio_end, stopping test.")
            self.audio_end_received = True
            ten_env.stop_test()

    def on_audio_frame(self, ten_env: TenEnvTester, audio_frame):
        """Receives audio frames and collects their data."""
        buf = audio_frame.lock_buf()
        try:
            copied_data = bytes(buf)
            self.received_audio_chunks.append(copied_data)
        finally:
            audio_frame.unlock_buf(buf)


@patch("elevenlabs_tts2_python.extension.ElevenLabsTTS2")
def test_basic_functionality(MockElevenLabsTTS2):
    """Test basic TTS functionality."""
    # Mock the ElevenLabsTTS2 class
    mock_client_instance = AsyncMock()

    # Mock the start_connection method
    mock_client_instance.start_connection = AsyncMock()

    # Mock the text_input_queue to avoid blocking
    mock_client_instance.text_input_queue = asyncio.Queue()

    # Mock the text_to_speech_ws_streaming method to consume from queue
    async def mock_text_to_speech_ws_streaming():
        while True:
            try:
                await mock_client_instance.text_input_queue.get()
            except asyncio.CancelledError:
                break

    mock_client_instance.text_to_speech_ws_streaming = (
        mock_text_to_speech_ws_streaming
    )

    # Mock the get_synthesized_audio method to return audio data
    audio_data_queue = asyncio.Queue()
    # Pre-populate the queue
    audio_data_queue.put_nowait([b"fake_audio_data_1", False, ""])
    audio_data_queue.put_nowait(
        [b"fake_audio_data_2", True, "hello word, hello agora"]
    )

    async def mock_get_synthesized_audio():
        try:
            return await audio_data_queue.get()
        except asyncio.QueueEmpty:
            # If the queue is empty, return a special value to stop the loop
            return [None, True, "STOP_LOOP"]

    mock_client_instance.get_synthesized_audio = mock_get_synthesized_audio
    MockElevenLabsTTS2.return_value = mock_client_instance

    # Create and run the tester
    tester = ExtensionTesterBasic()
    tester.set_test_mode_single("elevenlabs_tts2_python")
    tester.run()

    # Verify that audio end was received
    assert tester.audio_end_received, "Audio end event was not received"
    assert (
        len(tester.received_audio_chunks) > 0
    ), "No audio chunks were received"
